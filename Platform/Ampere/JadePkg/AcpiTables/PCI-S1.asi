/** @file

  Copyright (c) 2020 - 2023, Ampere Computing LLC. All rights reserved.<BR>

  SPDX-License-Identifier: BSD-2-Clause-Patent

**/

  //
  // S1 Start here
  //

  // PCIE6 S1 RCA2
  Device (PCIA) {
    //
    // Hardware ID must be PNP0A08, which maps to a PCIe root complex.
    // Section 6.1.5
    //

    Name (_HID,"PNP0A08")
    Name (_CCA, ONE)

    Method (_STA, 0, NotSerialized) {
      Return (0xF)
    }

    //
    // Optionally, include a compatible ID of PNP0A03, which maps to a PCI
    // root complex for use with pre-PCIe operating systems.
    // Section 6.1.2
    //

    Name (_CID,"PNP0A03")

    //
    // Declare the segment number of this root complex. Most systems only
    // have one segment, which is numbered 0.
    // Section 6.5.6
    //

    Name (_SEG, 6)

    //
    // Declare the base bus number, which is the bus number of the root
    // bus in this root complex. This is usually 0, but need not be.
    // For root complexes supporting multiple root busses, this should
    // be the lowest numbered root bus.
    // Section 6.5.5
    //

    Name (_BBN, 0)

    //
    // The _UID value provides a way of uniquely identifying a device
    // in the case where more than one instance of a specific device
    // is implemented with the same _HID/_CID. For systems with a
    // single root complex, this is usually just 0. For systems with
    // multiple root complexes, this should be different for each
    // root complex.
    // Section 6.1.12
    //

    Name (_UID, "PCIA")
    Name (_STR, Unicode("PCIe 10 Device"))

    //
    // Declare the PCI Routing Table.
    // This defines SPI mappings of the four line-based interrupts
    // associated with the root complex and hierarchy below it.
    // Section 6.2.12
    //

    Name (_PRT, Package() {

      //
      // Routing for device 0, all functions.
      // Note: ARM doesn't support LNK nodes, so the third param
      // is 0 and the fourth param is the SPI number of the interrupt
      // line. In this example, the A/B/C/D interrupts are wired to
      // SPI lines 136/137/138/139 + 320 respectively. PCIA RCA2
      //
      Package() {0x0001FFFF, 0, 0, 456},
      Package() {0x0001FFFF, 1, 0, 457},
      Package() {0x0001FFFF, 2, 0, 458},
      Package() {0x0001FFFF, 3, 0, 459},
      Package() {0x0002FFFF, 0, 0, 456},
      Package() {0x0002FFFF, 1, 0, 457},
      Package() {0x0002FFFF, 2, 0, 458},
      Package() {0x0002FFFF, 3, 0, 459},
      Package() {0x0003FFFF, 0, 0, 456},
      Package() {0x0003FFFF, 1, 0, 457},
      Package() {0x0003FFFF, 2, 0, 458},
      Package() {0x0003FFFF, 3, 0, 459},
      Package() {0x0004FFFF, 0, 0, 456},
      Package() {0x0004FFFF, 1, 0, 457},
      Package() {0x0004FFFF, 2, 0, 458},
      Package() {0x0004FFFF, 3, 0, 459},
    })

    //
    // Declare the resources assigned to this root complex.
    // Section 6.2.2
    //
    Method (_CBA, 0, Serialized) {
      Return (0x7BFFF0000000)
    }

    //
    // Declare a ResourceTemplate buffer to return the resource
    // requirements from _CRS.
    // Section 19.5.109
    //

    Name (RBUF, ResourceTemplate () {

      //
      // Declare the range of bus numbers assigned to this root
      // complex. In this example, the minimum bus number will be
      // 0, the maximum bus number will be 0xFF, supporting
      // 256 busses total.
      // Section 19.5.141
      //

      WordBusNumber (
        ResourceProducer,
        MinFixed,   // IsMinFixed
        MaxFixed,   // IsMaxFixed
        PosDecode,  // Decode
        0,          // AddressGranularity
        0,          // AddressMinimum - Minimum Bus Number
        255,        // AddressMaximum - Maximum Bus Number
        0,          // AddressTranslation - Set to 0
        256)        // RangeLength - Number of Busses

      //
      // Declare the memory range to be used for BAR memory
      // windows. This declares a 4GB region starting at
      // 0x4000000000.
      // Section 19.5.80
      //
      // Memory32Fixed (ReadWrite, 0x1FF80000, 0x10000, )

      QWordMemory (
        ResourceProducer,     // ResourceUsage
        PosDecode,            // Decode
        MinFixed,             // IsMinFixed
        MaxFixed,             // IsMaxFixed
        NonCacheable,         // NonCacheable
        ReadWrite,            // ReadAndWrite
        0x0000000000000000,   // AddressGranularity - GRA
        0x0000000070000000,   // AddressMinimum - MIN
        0x0000000077FFFFFF,   // AddressMinimum - MAX
        0x0000000000000000,   // AddressTranslation - TRA
        0x0000000008000000    // RangeLength - LEN
      )

      QWordMemory (
        ResourceProducer,     // ResourceUsage
        PosDecode,            // Decode
        MinFixed,             // IsMinFixed
        MaxFixed,             // IsMaxFixed
        NonCacheable,         // NonCacheable
        ReadWrite,            // ReadAndWrite
        0x0000000000000000,   // AddressGranularity - GRA
        0x0000780000000000,   // AddressMinimum - MIN
        0x00007BFFDFFFFFFF,   // AddressMaximum - MAX
        0x0000000000000000,   // AddressTranslation - TRA
        0x000003FFE0000000    // RangeLength - LEN
      )
    })

    Method (_CRS, 0, Serialized) {
      Return (RBUF)
    }

    //
    // Declare an _OSC (OS Control Handoff) method which takes 4 arguments.
    //
    // Argments:
    //   Arg0  A Buffer containing a UUID
    //   Arg1  An Integer containing a Revision ID of the buffer format
    //   Arg2  An Integer containing a count of entries in Arg3
    //   Arg3  A Buffer containing a list of DWORD capabilities
    // Return Value:
    //   A Buffer containing a list of capabilities
    // See the APCI spec, Section 6.2.10,
    // and the PCI FW spec, Section 4.5.
    //
    // The following is an example, and may need modification for
    // specific implementations.
    //

    Name (SUPP,0) // PCI _OSC Support Field value
    Name (CTRL,0) // PCI _OSC Control Field value

    Method (_OSC, 4) {

      //
      // Look for the PCI Host Bridge Interface UUID.
      // Section 6.2.10.3
      //

      //
      // Create DWord-adressable fields from the Capabilities Buffer
      // Create CDW1 outside the test as it's used in the else clause.
      //

      CreateDWordField (Arg3,0,CDW1)
      If (LEqual (Arg0,ToUUID("33DB4D5B-1FF7-401C-9657-7441C03DD766"))) {

        CreateDWordField (Arg3,4,CDW2)
        CreateDWordField (Arg3,8,CDW3)

        //
        // Save Capabilities DWord 2 & 3
        //

        Store (CDW2,SUPP)
        Store (CDW3,CTRL)

        //
        // Only allow native hot plug control if OS supports:
        //  ASPM
        //  Clock PM
        //  MSI/MSI-X
        //

        If (LNotEqual (And (SUPP, 0x16), 0x16)) {

          //
          // Mask bit 0 (and undefined bits)
          //

          And (CTRL,0x1E,CTRL)
        }

        //
        // Never allow native Hot plug, PME.
        // Never allow SHPC (no SHPC controller in this system).
        // Only allow PCIe AER control if PCIe AER Firmware-First is disabled
        // Allows PCI Express Capability Structure control
        //

        If (AERF) {
          And (CTRL, 0x10, CTRL)
        } Else {
          And (CTRL, 0x18, CTRL)
        }

        //
        // Check for unknown revision.
        //

        If (LNotEqual (Arg1,One)) {
          Or (CDW1,0x08,CDW1)
        }

        //
        // Check if capabilities bits were masked.
        //

        If (LNotEqual (CDW3,CTRL)) {
          Or (CDW1,0x10,CDW1)
        }

        //
        // Update DWORD3 in the buffer.
        //

        Store (CTRL,CDW3)
        Return (Arg3)
      } Else {

        //
        // Unrecognized UUID
        //

        Or (CDW1,4,CDW1)
        Return (Arg3)
      }
    } // End _OSC

    //
    // Declare a _DSM method for various functions called by the OS.
    // See the APCI spec, Section 9.14.1,
    // and the PCI FW spec, Section 4.6.
    // See also:
    // http://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/PCI-rsc.doc
    //

    Method (_DSM, 0x4, Serialized) {

      //
      // Match against the _DSM PCI GUID.
      //

      If (LEqual (Arg0,ToUUID("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {

        Switch (ToInteger(Arg2)) {
          //
          // Function 0: Return supported functions as a bitfield
          // with one bit for each supported function.
          // Bit 0 must always be set, as that represents
          // function 0 (which is what is being called here).
          // Support for different functions may depend on
          // the revision ID of the interface, passed as Arg1.
          //

          Case (0) {

              //
              // Functions 0-7 are supported.
              //

              Return (Buffer() {0x01})
          }
        }
      }

      //
      // If not one of the function identifiers we recognize, then return a buffer
      // with bit 0 set to 0 indicating no functions supported.
      //

      Return (Buffer() {0})
    }

    //
    // Root Port 0 Device within the Root Complex.
    //
    Device (RP0) {
      //
      // Device 0, Function 0.
      //

      Name (_ADR, 0x00000000)
    }

    //
    // Root Port 1
    //
    Device (P2P1) {
      //
      // Device 1, Function 0 (Bus 0).
      //

      Name (_ADR, 0x00010000)
      Name(_HPP, Package(){0x08,0x40, 0x01, 0x00})

      Device (S0F0) {
        //
        // On Bus 1 ([01])
        // Slot 0 (Device 0), Function 0
        //

        Name (_ADR, 0x00000000)

        Method (_STA, 0) {
          if (A120 == 0xF0000201) { // SW ejected before ?
            Store(0x02000201, A120) // clear action value
            Store(0x680000A4, DIN0) // Off RED LED
                                    // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                    // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
            Store(0x68000216, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                    // action: Insert = 1 & Remove = 2
                                    // 0x68000216 to DBNS1_10
            Return (0xF)
          }
          elseif (A120 == 0x10000201) { // ejected completed ?
            Store(0x02000201, A120) // clear action value
            Return (0x0)
          }
          elseif ((A120 == 0x01000201) || (A120 == 0x0F000201)) { // inserted ?
            if (A16I == 0x00) {
              Store(0x02000201, A120) // clear action value
            }
            Return (0xF)
          }
          elseif ((A120 == 0x0E000201) || (A120 == 0x0F000201)) { // inprogress inserted ?
            if (A16I == 0x00) {
              Store(0x02000201, A120) // clear action value
            }
            Return (0xF)
          }
          else {
            Return (0xF)
          }
        }

        Method (_EJ0, 1) {
          if (A120 == 0x02000201) { // is sw ejection?
            Store(0xF0000201, A120) // set SW ejection event
            Store(0x680000B4, DIN0) // Blink RED LED
                                    // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                    // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
            Store(0x68000216, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                    // action: Insert = 1 & Remove = 2
                                    // 0x68000216 to DBNS1_10
          }
        }

        Name(_SUN, 0x00000001)
      }
    }

    //
    // Root Port 2
    //
    Device (P2P2) {
      //
      // Device 2, Function 0 (Bus 0).
      //

      Name (_ADR, 0x00020000)
      Name(_HPP, Package(){0x08,0x40, 0x01, 0x00})

      Device (S0F0) {
        //
        // On Bus 2 ([02])
        // Slot 0 (Device 0), Function 0
        //

        Name (_ADR, 0x00000000)

        Method (_STA, 0) {
          if (A121 == 0xF0010201) { // SW ejected before ?
            Store(0x02010201, A121) // clear action value
            Store(0x680000A4, DIN0) // Off RED LED
                                    // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                    // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
            Store(0x68000226, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                    // action: Insert = 1 & Remove = 2
                                    // 0x68000226 to DBNS1_10
            Return(0xF)
          }
          elseif (A121 == 0x10010201) { // ejected completed ?
            Store(0x02010201, A121) // clear action value
            Return(0x0)
          }
          elseif ((A121 == 0x01010201) || (A121 == 0x0F010201)) { // inserted ?
            if (A17I == 0x00) {
              Store(0x02010201, A121) // clear action value
            }
            Return(0xF)
          }
          elseif ((A121 == 0x0E010201) || (A121 == 0x0F010201)) { // inprogress inserted ?
            if (A17I == 0x00) {
              Store(0x02010201, A121) // clear action value
            }
            Return(0xF)
          }
          else {
            Return (0xF)
          }
        }

        Method (_EJ0, 1) {
          if (A121 == 0x02010201) { // is sw ejection?
            Store(0xF0010201, A121) // set SW ejection event
            Store(0x680000B4, DIN0) // Blink RED LED
                                    // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                    // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
            Store(0x68000226, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                    // action: Insert = 1 & Remove = 2
                                    // 0x68000226 to DBNS1_10
          }
        }

        Name(_SUN, 0x00000002)
      }
    }

    //
    // Root Port 3
    //
    Device (P2P3) {
      //
      // Device 3, Function 0 (Bus 0).
      //

      Name (_ADR, 0x00030000)
      Name(_HPP, Package(){0x08,0x40, 0x01, 0x00})

      Device (S0F0) {
        //
        // On Bus 3 [03])
        // Slot 0 (Device 0), Function 0
        //

        Name (_ADR, 0x00000000)

        Method (_STA, 0) {
          if (A122 == 0xF0020201) { // SW ejected before ?
            Store(0x02020201, A122) // clear action value
            Store(0x680000A4, DIN0) // Off RED LED
                                    // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                    // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
            Store(0x68000236, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                    // action: Insert = 1 & Remove = 2
                                    // 0x68000236 to DBNS1_10
            Return(0xF)
          }
          elseif (A122 == 0x10020201) { // ejected complete ?
            Store(0x02020201, A122) // clear action value
            Return (0x0)
          }
          elseif ((A122 == 0x01020201) || (A122 == 0x0F020201)) { // inserted ?
            if (A18I == 0x00) {
              Store(0x02020201, A122) // clear action value
            }
            Return (0xF)
          }
          elseif ((A122 == 0x0E020201) || (A122 == 0x0F020201)) { // inprogess inserted ?
            if (A18I == 0x00) {
              Store(0x02020201, A122) // clear action value
            }
            Return (0xF)
          }
          else {
            Return (0xF)
          }
        }

        Method (_EJ0, 1) {
          if (A122 == 0x02020201) { // is sw ejection?
            Store(0xF0020201, A122) // set SW ejection event
            Store(0x680000B4, DIN0) // Blink RED LED
                                    // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                    // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
            Store(0x68000236, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                    // action: Insert = 1 & Remove = 2
                                    // 0x68000236 to DBNS1_10
          }
        }

        Name(_SUN, 0x00000003)
      }
    }

    //
    // Root Port 4
    //
    Device (P2P4) {
      //
      // Device 4, Function 0 (Bus 0).
      //

      Name (_ADR, 0x00040000)
      Name(_HPP, Package(){0x08,0x40, 0x01, 0x00})

      Device (S0F0) {
        //
        // On Bus 4 [04])
        // Slot 0 (Device 0), Function 0
        //

        Name (_ADR, 0x00000000)

        Method (_STA, 0) {
          if (A123 == 0xF0030201) { // SW ejected before ?
            Store(0x02030201, A123) // clear action value
            Store(0x680000A4, DIN0) // Off RED LED
                                    // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                    // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
            Store(0x68000246, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                    // action: Insert = 1 & Remove = 2
                                    // 0x68000246 to DBNS1_10
            Return(0xF)
          }
          elseif (A123 == 0x10030201) { // ejected complete ?
            Store(0x02030201, A123) // clear action value
            Return (0x0)
          }
          elseif ((A123 == 0x01030201) || (A123 == 0x0F030201)) { // inserted ?
            if (A19I == 0x00) {
              Store(0x02030201, A123) // clear action value
            }
            Return (0xF)
          }
          elseif ((A123 == 0x0E030201) || (A123 == 0x0F030201)) { // inprogress inserted ?
            if (A19I == 0x00) {
              Store(0x02030201, A123) // clear action value
            }
            Return (0xF)
          }
          else {
            Return (0xF)
          }
        }

        Method (_EJ0, 1) {
          if (A123 == 0x02030201) { // is sw ejection?
            Store(0xF0030201, A123) // set ejection event
            Store(0x680000B4, DIN0) // Blink RED LED
                                    // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                    // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
            Store(0x68000246, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                    // action: Insert = 1 & Remove = 2
                                    // 0x68000246 to DBNS1_10
          }
        }

        Name(_SUN, 0x00000004)
      }
    }

    Method (_PXM, 0, NotSerialized) {
      // Patch by code
      Return(0xFF)
    }
  } // PCIA RCA2

  // PCIEB RCA3
  Device (PCIB) {
    //
    // Hardware ID must be PNP0A08, which maps to a PCIe root complex.
    // Section 6.1.5
    //

    Name (_HID,"PNP0A08")
    Name (_CCA, ONE)

    Method (_STA, 0, NotSerialized) {
      Return (0xF)
    }

    //
    // Optionally, include a compatible ID of PNP0A03, which maps to a PCI
    // root complex for use with pre-PCIe operating systems.
    // Section 6.1.2
    //

    Name (_CID,"PNP0A03")

    //
    // Declare the segment number of this root complex. Most systems only
    // have one segment, which is numbered 0.
    // Section 6.5.6
    //

    Name (_SEG, 7)

    //
    // Declare the base bus number, which is the bus number of the root
    // bus in this root complex. This is usually 0, but need not be.
    // For root complexes supporting multiple root busses, this should
    // be the lowest numbered root bus.
    // Section 6.5.5
    //

    Name (_BBN, 0)

    //
    // The _UID value provides a way of uniquely identifying a device
    // in the case where more than one instance of a specific device
    // is implemented with the same _HID/_CID. For systems with a
    // single root complex, this is usually just 0. For systems with
    // multiple root complexes, this should be different for each
    // root complex.
    // Section 6.1.12
    //

    Name (_UID, "PCIB")
    Name (_STR, Unicode("PCIe 11 Device"))

    //
    // Declare the PCI Routing Table.
    // This defines SPI mappings of the four line-based interrupts
    // associated with the root complex and hierarchy below it.
    // Section 6.2.12
    //

    Name (_PRT, Package() {

      //
      // Routing for device 0, all functions.
      // Note: ARM doesn't support LNK nodes, so the third param
      // is 0 and the fourth param is the SPI number of the interrupt
      // line. In this example, the A/B/C/D interrupts are wired to
      // SPI lines 140/141/142/143 + 320 respectively. PCIB RCA3
      //
      Package() {0x0001FFFF, 0, 0, 460},
      Package() {0x0001FFFF, 1, 0, 461},
      Package() {0x0001FFFF, 2, 0, 462},
      Package() {0x0001FFFF, 3, 0, 463},
      Package() {0x0002FFFF, 0, 0, 460},
      Package() {0x0002FFFF, 1, 0, 461},
      Package() {0x0002FFFF, 2, 0, 462},
      Package() {0x0002FFFF, 3, 0, 463},
      Package() {0x0003FFFF, 0, 0, 460},
      Package() {0x0003FFFF, 1, 0, 461},
      Package() {0x0003FFFF, 2, 0, 462},
      Package() {0x0003FFFF, 3, 0, 463},
      Package() {0x0004FFFF, 0, 0, 460},
      Package() {0x0004FFFF, 1, 0, 461},
      Package() {0x0004FFFF, 2, 0, 462},
      Package() {0x0004FFFF, 3, 0, 463},
    })

    //
    // Declare the resources assigned to this root complex.
    // Section 6.2.2
    //
    Method (_CBA, 0, Serialized) {
      Return (0x7FFFF0000000)
    }

    //
    // Declare a ResourceTemplate buffer to return the resource
    // requirements from _CRS.
    // Section 19.5.109
    //

    Name (RBUF, ResourceTemplate () {

      //
      // Declare the range of bus numbers assigned to this root
      // complex. In this example, the minimum bus number will be
      // 0, the maximum bus number will be 0xFF, supporting
      // 256 busses total.
      // Section 19.5.141
      //

      WordBusNumber (
        ResourceProducer,
        MinFixed,   // IsMinFixed
        MaxFixed,   // IsMaxFixed
        PosDecode,  // Decode
        0,          // AddressGranularity
        0,          // AddressMinimum - Minimum Bus Number
        255,        // AddressMaximum - Maximum Bus Number
        0,          // AddressTranslation - Set to 0
        256)        // RangeLength - Number of Busses

      //
      // Declare the memory range to be used for BAR memory
      // windows. This declares a 4GB region starting at
      // 0x4000000000.
      // Section 19.5.80
      //
      // Memory32Fixed (ReadWrite, 0x1FFC0000, 0x10000, )

      QWordMemory (
        ResourceProducer,     // ResourceUsage
        PosDecode,            // Decode
        MinFixed,             // IsMinFixed
        MaxFixed,             // IsMaxFixed
        NonCacheable,         // NonCacheable
        ReadWrite,            // ReadAndWrite
        0x0000000000000000,   // AddressGranularity - GRA
        0x0000000078000000,   // AddressMinimum - MIN
        0x000000007FFFFFFF,   // AddressMinimum - MAX
        0x0000000000000000,   // AddressTranslation - TRA
        0x0000000008000000    // RangeLength - LEN
      )

      QWordMemory (
        ResourceProducer,     // ResourceUsage
        PosDecode,            // Decode
        MinFixed,             // IsMinFixed
        MaxFixed,             // IsMaxFixed
        NonCacheable,         // NonCacheable
        ReadWrite,            // ReadAndWrite
        0x0000000000000000,   // AddressGranularity - GRA
        0x00007C0000000000,   // AddressMinimum - MIN
        0x00007FFFDFFFFFFF,   // AddressMaximum - MAX
        0x0000000000000000,   // AddressTranslation - TRA
        0x000003FFE0000000    // RangeLength - LEN
      )
    })

    Method (_CRS, 0, Serialized) {
      Return (RBUF)
    }

    //
    // Declare an _OSC (OS Control Handoff) method which takes 4 arguments.
    //
    // Argments:
    //   Arg0  A Buffer containing a UUID
    //   Arg1  An Integer containing a Revision ID of the buffer format
    //   Arg2  An Integer containing a count of entries in Arg3
    //   Arg3  A Buffer containing a list of DWORD capabilities
    // Return Value:
    //   A Buffer containing a list of capabilities
    // See the APCI spec, Section 6.2.10,
    // and the PCI FW spec, Section 4.5.
    //
    // The following is an example, and may need modification for
    // specific implementations.
    //

    Name (SUPP,0) // PCI _OSC Support Field value
    Name (CTRL,0) // PCI _OSC Control Field value

    Method (_OSC, 4) {

      //
      // Look for the PCI Host Bridge Interface UUID.
      // Section 6.2.10.3
      //

      //
      // Create DWord-adressable fields from the Capabilities Buffer
      // Create CDW1 outside the test as it's used in the else clause.
      //

      CreateDWordField (Arg3,0,CDW1)
      If (LEqual (Arg0,ToUUID("33DB4D5B-1FF7-401C-9657-7441C03DD766"))) {

        CreateDWordField (Arg3,4,CDW2)
        CreateDWordField (Arg3,8,CDW3)

        //
        // Save Capabilities DWord 2 & 3
        //

        Store (CDW2,SUPP)
        Store (CDW3,CTRL)

        //
        // Only allow native hot plug control if OS supports:
        //  ASPM
        //  Clock PM
        //  MSI/MSI-X
        //

        If (LNotEqual (And (SUPP, 0x16), 0x16)) {

          //
          // Mask bit 0 (and undefined bits)
          //

          And (CTRL,0x1E,CTRL)
        }

        //
        // Never allow native Hot plug, PME.
        // Never allow SHPC (no SHPC controller in this system).
        // Only allow PCIe AER control if PCIe AER Firmware-First is disabled
        // Allows PCI Express Capability Structure control
        //

        If (AERF) {
          And (CTRL, 0x10, CTRL)
        } Else {
          And (CTRL, 0x18, CTRL)
        }

        //
        // Check for unknown revision.
        //

        If (LNotEqual (Arg1,One)) {
            Or (CDW1,0x08,CDW1)
        }

        //
        // Check if capabilities bits were masked.
        //

        If (LNotEqual (CDW3,CTRL)) {
            Or (CDW1,0x10,CDW1)
        }

        //
        // Update DWORD3 in the buffer.
        //

        Store (CTRL,CDW3)
        Return (Arg3)
      } Else {

        //
        // Unrecognized UUID
        //

        Or (CDW1,4,CDW1)
        Return (Arg3)
      }
    } // End _OSC

    //
    // Declare a _DSM method for various functions called by the OS.
    // See the APCI spec, Section 9.14.1,
    // and the PCI FW spec, Section 4.6.
    // See also:
    // http://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/PCI-rsc.doc
    //

    Method (_DSM, 0x4, Serialized) {

      //
      // Match against the _DSM PCI GUID.
      //

      If (LEqual (Arg0,ToUUID("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {

        Switch (ToInteger(Arg2)) {
          //
          // Function 0: Return supported functions as a bitfield
          // with one bit for each supported function.
          // Bit 0 must always be set, as that represents
          // function 0 (which is what is being called here).
          // Support for different functions may depend on
          // the revision ID of the interface, passed as Arg1.
          //

          Case (0) {

              //
              // Functions 0-7 are supported.
              //

              Return (Buffer() {0x01})
          }
        }
      }

      //
      // If not one of the function identifiers we recognize, then return a buffer
      // with bit 0 set to 0 indicating no functions supported.
      //

      Return (Buffer() {0})
    }

    //
    // Root Port 0 Device within the Root Complex.
    //
    Device (RP0) {
      //
      // Device 0, Function 0.
      //

      Name (_ADR, 0x00000000)
    }

    Method (_PXM, 0, NotSerialized) {
      // Patch by code
      Return(0xFF)
    }
  } // PCIB RCA3

  // PCIC RCB0
  Device (PCIC) {
    //
    // Hardware ID must be PNP0A08, which maps to a PCIe root complex.
    // Section 6.1.5
    //

    Name (_HID, "PNP0A08")
    Name (_CCA, ONE)

    Method (_STA, 0, NotSerialized) {
      Return (0xF)                      // The default value is 0x0. Unfortunately, it breaks
                                        // run-time patching as the representation of 0 is special
                                        // encoding and cannot be patched to expand with extra bytes
                                        // easily. As such, we default to 0xF and patch this based
                                        // on whether the port was enabled or not by the BIOS.
    }

    //
    // Optionally, include a compatible ID of PNP0A03, which maps to a PCI
    // root complex for use with pre-PCIe operating systems.
    // Section 6.1.2
    //

    Name (_CID, "PNP0A03")

    //
    // Declare the segment number of this root complex. Most systems only
    // have one segment, which is numbered 0.
    // Section 6.5.6
    //

    Name (_SEG, 8)

    //
    // Declare the base bus number, which is the bus number of the root
    // bus in this root complex. This is usually 0, but need not be.
    // For root complexes supporting multiple root busses, this should
    // be the lowest numbered root bus.
    // Section 6.5.5
    //

    Name (_BBN, 0)

    //
    // The _UID value provides a way of uniquely identifying a device
    // in the case where more than one instance of a specific device
    // is implemented with the same _HID/_CID. For systems with a
    // single root complex, this is usually just 0. For systems with
    // multiple root complexes, this should be different for each
    // root complex.
    // Section 6.1.12
    //

    Name (_UID, "PCIC")
    Name (_STR, Unicode("PCIe 12 Device"))

    //
    // Declare the PCI Routing Table.
    // This defines SPI mappings of the four line-based interrupts
    // associated with the root complex and hierarchy below it.
    // Section 6.2.12
    //

    Name (_PRT, Package() {

      //
      // Routing for device 0, all functions.
      // Note: ARM doesn't support LNK nodes, so the third param
      // is 0 and the fourth param is the SPI number of the interrupt
      // line. In this example, the A/B/C/D interrupts are wired to
      // SPI lines 144/145/146/147 + 320 respectively. PCIC RCB0
      //
      Package() {0x0001FFFF, 0, 0, 464},
      Package() {0x0001FFFF, 1, 0, 465},
      Package() {0x0001FFFF, 2, 0, 466},
      Package() {0x0001FFFF, 3, 0, 467},
      Package() {0x0002FFFF, 0, 0, 464},
      Package() {0x0002FFFF, 1, 0, 465},
      Package() {0x0002FFFF, 2, 0, 466},
      Package() {0x0002FFFF, 3, 0, 467},
      Package() {0x0003FFFF, 0, 0, 464},
      Package() {0x0003FFFF, 1, 0, 465},
      Package() {0x0003FFFF, 2, 0, 466},
      Package() {0x0003FFFF, 3, 0, 467},
      Package() {0x0004FFFF, 0, 0, 464},
      Package() {0x0004FFFF, 1, 0, 465},
      Package() {0x0004FFFF, 2, 0, 466},
      Package() {0x0004FFFF, 3, 0, 467},
      Package() {0x0005FFFF, 0, 0, 464},
      Package() {0x0005FFFF, 1, 0, 465},
      Package() {0x0005FFFF, 2, 0, 466},
      Package() {0x0005FFFF, 3, 0, 467},
      Package() {0x0006FFFF, 0, 0, 464},
      Package() {0x0006FFFF, 1, 0, 465},
      Package() {0x0006FFFF, 2, 0, 466},
      Package() {0x0006FFFF, 3, 0, 467},
      Package() {0x0007FFFF, 0, 0, 464},
      Package() {0x0007FFFF, 1, 0, 465},
      Package() {0x0007FFFF, 2, 0, 466},
      Package() {0x0007FFFF, 3, 0, 467},
      Package() {0x0008FFFF, 0, 0, 464},
      Package() {0x0008FFFF, 1, 0, 465},
      Package() {0x0008FFFF, 2, 0, 466},
      Package() {0x0008FFFF, 3, 0, 467},
    })

    //
    // Declare the resources assigned to this root complex.
    // Section 6.2.2
    //
    Method (_CBA, 0, Serialized) {
      Return (0x63FFF0000000)
    }

    //
    // Declare a ResourceTemplate buffer to return the resource
    // requirements from _CRS.
    // Section 19.5.109
    //

    Name (RBUF, ResourceTemplate () {

      //
      // Declare the range of bus numbers assigned to this root
      // complex. In this example, the minimum bus number will be
      // 0, the maximum bus number will be 0xFF, supporting
      // 256 busses total.
      // Section 19.5.141
      //

      WordBusNumber (
        ResourceProducer,
        MinFixed,   // IsMinFixed
        MaxFixed,   // IsMaxFixed
        PosDecode,  // Decode
        0,          // AddressGranularity
        0,          // AddressMinimum - Minimum Bus Number
        255,        // AddressMaximum - Maximum Bus Number
        0,          // AddressTranslation - Set to 0
        256)        // RangeLength - Number of Busses

      //
      // Declare the memory range to be used for BAR memory
      // windows. This declares a 4GB region starting at
      // 0x4000000000.
      // Section 19.5.80
      //
      // Memory32Fixed (ReadWrite, 0x1FE40000, 0x10000, )

      QWordMemory (
        ResourceProducer,     // ResourceUsage
        PosDecode,            // Decode
        MinFixed,             // IsMinFixed
        MaxFixed,             // IsMaxFixed
        NonCacheable,         // NonCacheable
        ReadWrite,            // ReadAndWrite
        0x0000000000000000,   // AddressGranularity - GRA
        0x0000000040000000,   // AddressMinimum - MIN
        0x0000000047FFFFFF,   // AddressMinimum - MAX
        0x0000000000000000,   // AddressTranslation - TRA
        0x0000000008000000    // RangeLength - LEN
      )

      QWordMemory (
        ResourceProducer,     // ResourceUsage
        PosDecode,            // Decode
        MinFixed,             // IsMinFixed
        MaxFixed,             // IsMaxFixed
        NonCacheable,         // NonCacheable
        ReadWrite,            // ReadAndWrite
        0x0000000000000000,   // AddressGranularity - GRA
        0x0000600000000000,   // AddressMinimum - MIN
        0x000063FFDFFFFFFF,   // AddressMaximum - MAX
        0x0000000000000000,   // AddressTranslation - TRA
        0x000003FFE0000000    // RangeLength - LEN
      )
    })

    Method (_CRS, 0, Serialized) {
      Return (RBUF)
    }

    //
    // Declare an _OSC (OS Control Handoff) method which takes 4 arguments.
    //
    // Argments:
    //   Arg0  A Buffer containing a UUID
    //   Arg1  An Integer containing a Revision ID of the buffer format
    //   Arg2  An Integer containing a count of entries in Arg3
    //   Arg3  A Buffer containing a list of DWORD capabilities
    // Return Value:
    //   A Buffer containing a list of capabilities
    // See the APCI spec, Section 6.2.10,
    // and the PCI FW spec, Section 4.5.
    //
    // The following is an example, and may need modification for
    // specific implementations.
    //

    Name (SUPP,0) // PCI _OSC Support Field value
    Name (CTRL,0) // PCI _OSC Control Field value

    Method (_OSC, 4) {

      //
      // Look for the PCI Host Bridge Interface UUID.
      // Section 6.2.10.3
      //

      //
      // Create DWord-adressable fields from the Capabilities Buffer
      // Create CDW1 outside the test as it's used in the else clause.
      //

      CreateDWordField (Arg3, 0, CDW1)
      If (LEqual (Arg0, ToUUID("33DB4D5B-1FF7-401C-9657-7441C03DD766"))) {

        CreateDWordField (Arg3, 4, CDW2)
        CreateDWordField (Arg3, 8, CDW3)

        //
        // Save Capabilities DWord 2 & 3
        //

        Store (CDW2, SUPP)
        Store (CDW3, CTRL)

        //
        // Only allow native hot plug control if OS supports:
        //  ASPM
        //  Clock PM
        //  MSI/MSI-X
        //

        If (LNotEqual (And (SUPP, 0x16), 0x16)) {

          //
          // Mask bit 0 (and undefined bits)
          //

          And (CTRL, 0x1E, CTRL)
        }

        //
        // Never allow native Hot plug, PME.
        // Never allow SHPC (no SHPC controller in this system).
        // Only allow PCIe AER control if PCIe AER Firmware-First is disabled
        // Allows PCI Express Capability Structure control
        //

        If (AERF) {
          And (CTRL, 0x10, CTRL)
        } Else {
          And (CTRL, 0x18, CTRL)
        }

        //
        // Check for unknown revision.
        //

        If (LNotEqual (Arg1, One)) {
          Or (CDW1, 0x08, CDW1)
        }

        //
        // Check if capabilities bits were masked.
        //

        If (LNotEqual (CDW3, CTRL)) {
          Or (CDW1, 0x10, CDW1)
        }

        //
        // Update DWORD3 in the buffer.
        //

        Store (CTRL, CDW3)
        Return (Arg3)

      } Else {

        //
        // Unrecognized UUID
        //

        Or (CDW1, 4, CDW1)
        Return (Arg3)
      }
    } // End _OSC

    //
    // Declare a _DSM method for various functions called by the OS.
    // See the APCI spec, Section 9.14.1,
    // and the PCI FW spec, Section 4.6.
    // See also:
    // http://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/PCI-rsc.doc
    //

    Method (_DSM, 0x4, Serialized) {

      //
      // Match against the _DSM PCI GUID.
      //

      If (LEqual (Arg0, ToUUID("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {

        Switch (ToInteger(Arg2)) {
          //
          // Function 0: Return supported functions as a bitfield
          // with one bit for each supported function.
          // Bit 0 must always be set, as that represents
          // function 0 (which is what is being called here).
          // Support for different functions may depend on
          // the revision ID of the interface, passed as Arg1.
          //

          Case (0) {

              //
              // Functions 0-7 are supported.
              //

              Return (Buffer() {0x01})
          }
        }
      }

      //
      // If not one of the function identifiers we recognize, then return a buffer
      // with bit 0 set to 0 indicating no functions supported.
      //

      Return (Buffer() {0})
    }

    //
    // Root Port 0 Device within the Root Complex.
    //
    Device (RP0) {
      //
      // Device 0, Function 0.
      //

      Name (_ADR, 0x00000000)
    }

    //
    // Root Port 5
    //
    Device (P2P5) {
      //
      // Device 5, Function 0 (Bus 0).
      //

      Name (_ADR, 0x00050000)
      Name(_HPP, Package(){0x08,0x40, 0x01, 0x00})

      Device (S0F0) {
        //
        // On Bus 2 [02])
        // Slot 0 (Device 0), Function 0
        //

        Name (_ADR, 0x00000000)

        Method (_STA, 0) {
          if (B104 == 0xF0040401) { // SW ejected before ?
            Store(0x02040401, B104) // clear action value
            Store(0x680000A4, DIN0) // Off RED LED
                                    // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                    // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
            Store(0x68000258, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>>
                                    // action: Insert = 1 & Remove = 2
                                    // 0x68000258 to DBNS1_10
            Return(0xF)
          }
          elseif (B104 == 0x10040401) { // ejected complete ?
            Store(0x02040401, B104) // clear action value
            Return (0x0)
          }
          elseif ((B104 == 0x01040401) || (B104 == 0x0F040401)) { // inserted ?
            if (B23I == 0x00) {
              Store(0x02040401, B104) // clear action value
            }
            Return (0xF)
          }
          elseif ((B104 == 0x0E040401) || (B104 == 0x0F040401)) { // inprogress inserted ?
            if (B23I == 0x00) {
              Store(0x02040401, B104) // clear action value
            }
            Return (0xF)
          }
          else {
            Return (0xF)
          }
        }

        Method (_EJ0, 1) {
          if (B104 == 0x02040401) { // is sw ejection?
            Store(0xF0040401, B104) // set SW ejection event
            Store(0x680000B4, DIN0) // Blink RED LED
                                    // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                    // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
            Store(0x68000258, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                    // action: Insert = 1 & Remove = 2
                                    // 0x68000258 to DBNS1_10
          }
        }

        Name(_SUN, 0x00000002)
      }
    }

    //
    // Root Port 7
    //
    Device (P2P7) {
      //
      // Device 7, Function 0 (Bus 0).
      //

      Name (_ADR, 0x00070000)
      Name(_HPP, Package(){0x08,0x40, 0x01, 0x00})

      Device (S0F0) {
        //
        // On Bus 3 ([03])
        // Slot 0 (Device 0), Function 0
        //

        Name (_ADR, 0x00000000)

        Method (_STA, 0) {
          if (B106 == 0xF0060401) { // SW ejected before ?
            Store(0x02060401, B106) // clear action value
            Store(0x680000A4, DIN0) // Off RED LED
                                    // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                    // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
            Store(0x68000278, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                    // action: Insert = 1 & Remove = 2
                                    // 0x68000278 to DBNS1_10
            Return(0xF)
          }
          elseif (B106 == 0x10060401) { // ejected complete ?
            Store(0x02060401, B106) // clear action value
            Return (0x0)
          }
          elseif ((B106 == 0x01060401) || (B106 == 0x0F060401)) { // inserted ?
            if (B24I == 0x00) {
              Store(0x02060401, B106) // clear action value
            }
            Return (0xF)
          }
          elseif ((B106 == 0x0E060401) || (B106 == 0x0F060401)) { // inprogress inserted ?
            if (B24I == 0x00) {
              Store(0x02060401, B106) // clear action value
            }
            Return (0xF)
          }
          else {
            Return (0xF)
          }
        }

        Method (_EJ0, 1) {
          if (B106 == 0x02060401) { // is sw ejection?
            Store(0xF0060401, B106) // set SW ejection event
            Store(0x680000B4, DIN0) // Blink RED LED
                                    // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                    // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
            Store(0x68000278, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                    // action: Insert = 1 & Remove = 2
                                    // 0x68000278 to DBNS1_10
          }
        }

        Name(_SUN, 0x00000003)
      }
    }

    Method (_PXM, 0, NotSerialized) {
      // Patch by code
      Return(0xFF)
    }
  } // PCIC RCB0

  // PCID RCB1
  Device (PCID) {
    //
    // Hardware ID must be PNP0A08, which maps to a PCIe root complex.
    // Section 6.1.5
    //

    Name (_HID, "PNP0A08")
    Name (_CCA, ONE)

    Method (_STA, 0, NotSerialized) {
      Return (0xF)                      // The default value is 0x0. Unfortunately, it breaks
                                        // run-time patching as the representation of 0 is special
                                        // encoding and cannot be patched to expand with extra bytes
                                        // easily. As such, we default to 0xF and patch this based
                                        // on whether the port was enabled or not by the BIOS.
    }

    //
    // Optionally, include a compatible ID of PNP0A03, which maps to a PCI
    // root complex for use with pre-PCIe operating systems.
    // Section 6.1.2
    //

    Name (_CID, "PNP0A03")

    //
    // Declare the segment number of this root complex. Most systems only
    // have one segment, which is numbered 0.
    // Section 6.5.6
    //

    Name (_SEG, 9)

    //
    // Declare the base bus number, which is the bus number of the root
    // bus in this root complex. This is usually 0, but need not be.
    // For root complexes supporting multiple root busses, this should
    // be the lowest numbered root bus.
    // Section 6.5.5
    //

    Name (_BBN, 0)

    //
    // The _UID value provides a way of uniquely identifying a device
    // in the case where more than one instance of a specific device
    // is implemented with the same _HID/_CID. For systems with a
    // single root complex, this is usually just 0. For systems with
    // multiple root complexes, this should be different for each
    // root complex.
    // Section 6.1.12
    //

    Name (_UID, "PCID")
    Name (_STR, Unicode("PCIe 13 Device"))

    //
    // Declare the PCI Routing Table.
    // This defines SPI mappings of the four line-based interrupts
    // associated with the root complex and hierarchy below it.
    // Section 6.2.12
    //

    Name (_PRT, Package() {

      //
      // Routing for device 0, all functions.
      // Note: ARM doesn't support LNK nodes, so the third param
      // is 0 and the fourth param is the SPI number of the interrupt
      // line. In this example, the A/B/C/D interrupts are wired to
      // SPI lines 148/149/150/151 + 320 respectively. PCID RCB1
      //
      Package() {0x0001FFFF, 0, 0, 468},
      Package() {0x0001FFFF, 1, 0, 469},
      Package() {0x0001FFFF, 2, 0, 470},
      Package() {0x0001FFFF, 3, 0, 471},
      Package() {0x0002FFFF, 0, 0, 468},
      Package() {0x0002FFFF, 1, 0, 469},
      Package() {0x0002FFFF, 2, 0, 470},
      Package() {0x0002FFFF, 3, 0, 471},
      Package() {0x0003FFFF, 0, 0, 468},
      Package() {0x0003FFFF, 1, 0, 469},
      Package() {0x0003FFFF, 2, 0, 470},
      Package() {0x0003FFFF, 3, 0, 471},
      Package() {0x0004FFFF, 0, 0, 468},
      Package() {0x0004FFFF, 1, 0, 469},
      Package() {0x0004FFFF, 2, 0, 470},
      Package() {0x0004FFFF, 3, 0, 471},
      Package() {0x0005FFFF, 0, 0, 468},
      Package() {0x0005FFFF, 1, 0, 469},
      Package() {0x0005FFFF, 2, 0, 470},
      Package() {0x0005FFFF, 3, 0, 471},
      Package() {0x0006FFFF, 0, 0, 468},
      Package() {0x0006FFFF, 1, 0, 469},
      Package() {0x0006FFFF, 2, 0, 470},
      Package() {0x0006FFFF, 3, 0, 471},
      Package() {0x0007FFFF, 0, 0, 468},
      Package() {0x0007FFFF, 1, 0, 469},
      Package() {0x0007FFFF, 2, 0, 470},
      Package() {0x0007FFFF, 3, 0, 471},
      Package() {0x0008FFFF, 0, 0, 468},
      Package() {0x0008FFFF, 1, 0, 469},
      Package() {0x0008FFFF, 2, 0, 470},
      Package() {0x0008FFFF, 3, 0, 471},
    })

    //
    // Declare the resources assigned to this root complex.
    // Section 6.2.2
    //
    Method (_CBA, 0, Serialized) {
      Return (0x67FFF0000000)
    }

    //
    // Declare a ResourceTemplate buffer to return the resource
    // requirements from _CRS.
    // Section 19.5.109
    //

    Name (RBUF, ResourceTemplate () {

      //
      // Declare the range of bus numbers assigned to this root
      // complex. In this example, the minimum bus number will be
      // 0, the maximum bus number will be 0xFF, supporting
      // 256 busses total.
      // Section 19.5.141
      //

      WordBusNumber (
        ResourceProducer,
        MinFixed,   // IsMinFixed
        MaxFixed,   // IsMaxFixed
        PosDecode,  // Decode
        0,          // AddressGranularity
        0,          // AddressMinimum - Minimum Bus Number
        255,        // AddressMaximum - Maximum Bus Number
        0,          // AddressTranslation - Set to 0
        256)        // RangeLength - Number of Busses

      //
      // Declare the memory range to be used for BAR memory
      // windows. This declares a 4GB region starting at
      // 0x4000000000.
      // Section 19.5.80
      //
      // Memory32Fixed (ReadWrite, 0x1FE40000, 0x10000, )

      QWordMemory (
        ResourceProducer,     // ResourceUsage
        PosDecode,            // Decode
        MinFixed,             // IsMinFixed
        MaxFixed,             // IsMaxFixed
        NonCacheable,         // NonCacheable
        ReadWrite,            // ReadAndWrite
        0x0000000000000000,   // AddressGranularity - GRA
        0x0000000048000000,   // AddressMinimum - MIN
        0x000000004FFFFFFF,   // AddressMinimum - MAX
        0x0000000000000000,   // AddressTranslation - TRA
        0x0000000008000000    // RangeLength - LEN
      )

      QWordMemory (
        ResourceProducer,     // ResourceUsage
        PosDecode,            // Decode
        MinFixed,             // IsMinFixed
        MaxFixed,             // IsMaxFixed
        NonCacheable,         // NonCacheable
        ReadWrite,            // ReadAndWrite
        0x0000000000000000,   // AddressGranularity - GRA
        0x0000640000000000,   // AddressMinimum - MIN
        0x000067FFDFFFFFFF,   // AddressMaximum - MAX
        0x0000000000000000,   // AddressTranslation - TRA
        0x000003FFE0000000    // RangeLength - LEN
      )
    })

    Method (_CRS, 0, Serialized) {
      Return (RBUF)
    }

    //
    // Declare an _OSC (OS Control Handoff) method which takes 4 arguments.
    //
    // Argments:
    //   Arg0  A Buffer containing a UUID
    //   Arg1  An Integer containing a Revision ID of the buffer format
    //   Arg2  An Integer containing a count of entries in Arg3
    //   Arg3  A Buffer containing a list of DWORD capabilities
    // Return Value:
    //   A Buffer containing a list of capabilities
    // See the APCI spec, Section 6.2.10,
    // and the PCI FW spec, Section 4.5.
    //
    // The following is an example, and may need modification for
    // specific implementations.
    //

    Name (SUPP,0) // PCI _OSC Support Field value
    Name (CTRL,0) // PCI _OSC Control Field value

    Method (_OSC, 4) {

      //
      // Look for the PCI Host Bridge Interface UUID.
      // Section 6.2.10.3
      //

      //
      // Create DWord-adressable fields from the Capabilities Buffer
      // Create CDW1 outside the test as it's used in the else clause.
      //

      CreateDWordField (Arg3, 0, CDW1)
      If (LEqual (Arg0, ToUUID("33DB4D5B-1FF7-401C-9657-7441C03DD766"))) {

        CreateDWordField (Arg3, 4, CDW2)
        CreateDWordField (Arg3, 8, CDW3)

        //
        // Save Capabilities DWord 2 & 3
        //

        Store (CDW2, SUPP)
        Store (CDW3, CTRL)

        //
        // Only allow native hot plug control if OS supports:
        //  ASPM
        //  Clock PM
        //  MSI/MSI-X
        //

        If (LNotEqual (And (SUPP, 0x16), 0x16)) {

          //
          // Mask bit 0 (and undefined bits)
          //

          And (CTRL, 0x1E, CTRL)
        }

        //
        // Never allow native Hot plug, PME.
        // Never allow SHPC (no SHPC controller in this system).
        // Only allow PCIe AER control if PCIe AER Firmware-First is disabled
        // Allows PCI Express Capability Structure control
        //

        If (AERF) {
          And (CTRL, 0x10, CTRL)
        } Else {
          And (CTRL, 0x18, CTRL)
        }

        //
        // Check for unknown revision.
        //

        If (LNotEqual (Arg1, One)) {
          Or (CDW1, 0x08, CDW1)
        }

        //
        // Check if capabilities bits were masked.
        //

        If (LNotEqual (CDW3, CTRL)) {
          Or (CDW1, 0x10, CDW1)
        }

        //
        // Update DWORD3 in the buffer.
        //

        Store (CTRL, CDW3)
        Return (Arg3)

      } Else {

        //
        // Unrecognized UUID
        //

        Or (CDW1, 4, CDW1)
        Return (Arg3)
      }
    } // End _OSC

    //
    // Declare a _DSM method for various functions called by the OS.
    // See the APCI spec, Section 9.14.1,
    // and the PCI FW spec, Section 4.6.
    // See also:
    // http://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/PCI-rsc.doc
    //

    Method (_DSM, 0x4, Serialized) {

      //
      // Match against the _DSM PCI GUID.
      //

      If (LEqual (Arg0, ToUUID("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {

        Switch (ToInteger(Arg2)) {
          //
          // Function 0: Return supported functions as a bitfield
          // with one bit for each supported function.
          // Bit 0 must always be set, as that represents
          // function 0 (which is what is being called here).
          // Support for different functions may depend on
          // the revision ID of the interface, passed as Arg1.
          //

          Case (0) {

              //
              // Functions 0-7 are supported.
              //

              Return (Buffer() {0x01})
          }
        }
      }

      //
      // If not one of the function identifiers we recognize, then return a buffer
      // with bit 0 set to 0 indicating no functions supported.
      //

      Return (Buffer() {0})
    }

    //
    // Root Port 0 Device within the Root Complex.
    //
    Device (RP0) {
      //
      // Device 0, Function 0.
      //

      Name (_ADR, 0x00000000)
    }

    //
    // Root Port 1
    //
    Device (P2P1) {
      //
      // Device 1, Function 0 (Bus 0).
      //

      Name (_ADR, 0x00010000)
      Name(_HPP, Package(){0x08,0x40, 0x01, 0x00})

      Device (S0F0) {
        //
        // On Bus 1 ([01])
        // Slot 0 (Device 0), Function 0
        //

        Name (_ADR, 0x00000000)

        Method (_STA, 0) {
          if (B110 == 0xF0000501) { // SW ejected before?
            Store(0x02000501, B110) // clear action value
            Store(0x680000A4, DIN0) // Off RED LED
                                    // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                    // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
            Store(0x68000219, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                    // action: Insert = 1 & Remove = 2
                                    // 0x68000219 to DBNS1_10
            Return(0xF)
          }
          elseif (B110 == 0x10000501) { // ejected complete ?
            Store(0x02000501, B110) // clear action value
            Return (0x0)
          }
          elseif ((B110 == 0x01000501) || (B110 == 0x0F000501)) { // inserted ?
            if (B25I == 0x00) {
              Store(0x02000501, B110) // clear action value
            }
            Return (0xF)
          }
          elseif ((B110 == 0x0E000501) || (B110 == 0x0F000501)) { // inprogress inserted ?
            if (B25I == 0x00) {
              Store(0x02000501, B110) // clear action value
            }
            Return (0xF)
          }
          else {
            Return (0xF)
          }
        }

        Method (_EJ0, 1) {
          if (B110 == 0x02000501) { // is sw ejection?
            Store(0xF0000501, B110) // set SW ejection event
            Store(0x680000B4, DIN0) // Blink RED LED
                                    // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                    // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
            Store(0x68000219, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                    // action: Insert = 1 & Remove = 2
                                    // 0x68000219 to DBNS1_10
          }
        }

        Name(_SUN, 0x00000001)
      }
    }

    //
    // Root Port 3
    //
    Device (P2P3) {
      //
      // Device 3, Function 0 (Bus 0).
      //

      Name (_ADR, 0x00030000)
      Name(_HPP, Package(){0x08,0x40, 0x01, 0x00})

      Device (S0F0) {
        //
        // On Bus 2 [02])
        // Slot 0 (Device 0), Function 0
        //

        Name (_ADR, 0x00000000)

        Method (_STA, 0) {
          if (B112 == 0xF0020501) { // SW ejected before ?
            Store(0x02020501, B112) // clear action value
            Store(0x680000A4, DIN0) // Off RED LED
                                    // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                    // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
            Store(0x68000239, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                    // action: Insert = 1 & Remove = 2
                                    // 0x68000239 to DBNS1_10
            Return(0xF)
          }
          elseif (B112 == 0x10020501) { // ejected complete ?
            Store(0x02020501, B112) // clear action value
            Return (0x0)
          }
          elseif ((B112 == 0x01020501) || (B112 == 0x0F020501)) { // inserted ?
            if (B26I == 0x00) {
              Store(0x02020501, B112) // clear action value
            }
            Return (0xF)
          }
          elseif ((B112 == 0x0E020501) || (B112 == 0x0F020501)) { // inprogress inserted ?
            if (B26I == 0x00) {
              Store(0x02020501, B112) // clear action value
            }
            Return (0xF)
          }
          else {
            Return (0xF)
          }
        }

        Method (_EJ0, 1) {
          if (B112 == 0x02020501) { // is sw ejection?
            Store(0xF0020501, B112) // set SW ejection event
            Store(0x680000B4, DIN0) // Blink RED LED
                                    // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                    // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
            Store(0x68000239, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                    // action: Insert = 1 & Remove = 2
                                    // 0x68000239 to DBNS1_10
          }
        }

        Name(_SUN, 0x00000002)
      }
    }

    Method (_PXM, 0, NotSerialized) {
      // Patch by code
      Return(0xFF)
    }
  } // PCID RCB1

  // PCIE RCB2
  Device (PCIE) {
    //
    // Hardware ID must be PNP0A08, which maps to a PCIe root complex.
    // Section 6.1.5
    //

    Name (_HID, "PNP0A08")
    Name (_CCA, ONE)

    Method (_STA, 0, NotSerialized) {
      Return (0xF)                      // The default value is 0x0. Unfortunately, it breaks
                                        // run-time patching as the representation of 0 is special
                                        // encoding and cannot be patched to expand with extra bytes
                                        // easily. As such, we default to 0xF and patch this based
                                        // on whether the port was enabled or not by the BIOS.
    }

    //
    // Optionally, include a compatible ID of PNP0A03, which maps to a PCI
    // root complex for use with pre-PCIe operating systems.
    // Section 6.1.2
    //

    Name (_CID, "PNP0A03")

    //
    // Declare the segment number of this root complex. Most systems only
    // have one segment, which is numbered 0.
    // Section 6.5.6
    //

    Name (_SEG, 10)

    //
    // Declare the base bus number, which is the bus number of the root
    // bus in this root complex. This is usually 0, but need not be.
    // For root complexes supporting multiple root busses, this should
    // be the lowest numbered root bus.
    // Section 6.5.5
    //

    Name (_BBN, 0)

    //
    // The _UID value provides a way of uniquely identifying a device
    // in the case where more than one instance of a specific device
    // is implemented with the same _HID/_CID. For systems with a
    // single root complex, this is usually just 0. For systems with
    // multiple root complexes, this should be different for each
    // root complex.
    // Section 6.1.12
    //

    Name (_UID, "PCIE")
    Name (_STR, Unicode("PCIe 14 Device"))

    //
    // Declare the PCI Routing Table.
    // This defines SPI mappings of the four line-based interrupts
    // associated with the root complex and hierarchy below it.
    // Section 6.2.12
    //

    Name (_PRT, Package() {

      //
      // Routing for device 0, all functions.
      // Note: ARM doesn't support LNK nodes, so the third param
      // is 0 and the fourth param is the SPI number of the interrupt
      // line. In this example, the A/B/C/D interrupts are wired to
      // SPI lines 152/153/154/155 + 320 respectively. PCIE RCB2
      //
      Package() {0x0001FFFF, 0, 0, 472},
      Package() {0x0001FFFF, 1, 0, 473},
      Package() {0x0001FFFF, 2, 0, 474},
      Package() {0x0001FFFF, 3, 0, 475},
      Package() {0x0002FFFF, 0, 0, 472},
      Package() {0x0002FFFF, 1, 0, 473},
      Package() {0x0002FFFF, 2, 0, 474},
      Package() {0x0002FFFF, 3, 0, 475},
      Package() {0x0003FFFF, 0, 0, 472},
      Package() {0x0003FFFF, 1, 0, 473},
      Package() {0x0003FFFF, 2, 0, 474},
      Package() {0x0003FFFF, 3, 0, 475},
      Package() {0x0004FFFF, 0, 0, 472},
      Package() {0x0004FFFF, 1, 0, 473},
      Package() {0x0004FFFF, 2, 0, 474},
      Package() {0x0004FFFF, 3, 0, 475},
      Package() {0x0005FFFF, 0, 0, 472},
      Package() {0x0005FFFF, 1, 0, 473},
      Package() {0x0005FFFF, 2, 0, 474},
      Package() {0x0005FFFF, 3, 0, 475},
      Package() {0x0006FFFF, 0, 0, 472},
      Package() {0x0006FFFF, 1, 0, 473},
      Package() {0x0006FFFF, 2, 0, 474},
      Package() {0x0006FFFF, 3, 0, 475},
      Package() {0x0007FFFF, 0, 0, 472},
      Package() {0x0007FFFF, 1, 0, 473},
      Package() {0x0007FFFF, 2, 0, 474},
      Package() {0x0007FFFF, 3, 0, 475},
      Package() {0x0008FFFF, 0, 0, 472},
      Package() {0x0008FFFF, 1, 0, 473},
      Package() {0x0008FFFF, 2, 0, 474},
      Package() {0x0008FFFF, 3, 0, 475},
    })

    //
    // Declare the resources assigned to this root complex.
    // Section 6.2.2
    //
    Method (_CBA, 0, Serialized) {
      Return (0x6BFFF0000000)
    }

    //
    // Declare a ResourceTemplate buffer to return the resource
    // requirements from _CRS.
    // Section 19.5.109
    //

    Name (RBUF, ResourceTemplate () {

      //
      // Declare the range of bus numbers assigned to this root
      // complex. In this example, the minimum bus number will be
      // 0, the maximum bus number will be 0xFF, supporting
      // 256 busses total.
      // Section 19.5.141
      //

      WordBusNumber (
        ResourceProducer,
        MinFixed,   // IsMinFixed
        MaxFixed,   // IsMaxFixed
        PosDecode,  // Decode
        0,          // AddressGranularity
        0,          // AddressMinimum - Minimum Bus Number
        255,        // AddressMaximum - Maximum Bus Number
        0,          // AddressTranslation - Set to 0
        256)        // RangeLength - Number of Busses

      //
      // Declare the memory range to be used for BAR memory
      // windows. This declares a 4GB region starting at
      // 0x4000000000.
      // Section 19.5.80
      //
      // Memory32Fixed (ReadWrite, 0x1FE40000, 0x10000, )

      QWordMemory (
        ResourceProducer,     // ResourceUsage
        PosDecode,            // Decode
        MinFixed,             // IsMinFixed
        MaxFixed,             // IsMaxFixed
        NonCacheable,         // NonCacheable
        ReadWrite,            // ReadAndWrite
        0x0000000000000000,   // AddressGranularity - GRA
        0x0000000050000000,   // AddressMinimum - MIN
        0x0000000057FFFFFF,   // AddressMaximum - MAX
        0x0000000000000000,   // AddressTranslation - TRA
        0x0000000008000000    // RangeLength - LEN
      )

      QWordMemory (
        ResourceProducer,     // ResourceUsage
        PosDecode,            // Decode
        MinFixed,             // IsMinFixed
        MaxFixed,             // IsMaxFixed
        NonCacheable,         // NonCacheable
        ReadWrite,            // ReadAndWrite
        0x0000000000000000,   // AddressGranularity - GRA
        0x0000680000000000,   // AddressMinimum - MIN
        0x00006BFFDFFFFFFF,   // AddressMinimum - MAX
        0x0000000000000000,   // AddressTranslation - TRA
        0x000003FFE0000000    // RangeLength - LEN
      )
    })

    Method (_CRS, 0, Serialized) {
      Return (RBUF)
    }

    //
    // Declare an _OSC (OS Control Handoff) method which takes 4 arguments.
    //
    // Argments:
    //   Arg0  A Buffer containing a UUID
    //   Arg1  An Integer containing a Revision ID of the buffer format
    //   Arg2  An Integer containing a count of entries in Arg3
    //   Arg3  A Buffer containing a list of DWORD capabilities
    // Return Value:
    //   A Buffer containing a list of capabilities
    // See the APCI spec, Section 6.2.10,
    // and the PCI FW spec, Section 4.5.
    //
    // The following is an example, and may need modification for
    // specific implementations.
    //

    Name (SUPP,0) // PCI _OSC Support Field value
    Name (CTRL,0) // PCI _OSC Control Field value

    Method (_OSC, 4) {

      //
      // Look for the PCI Host Bridge Interface UUID.
      // Section 6.2.10.3
      //

      //
      // Create DWord-adressable fields from the Capabilities Buffer
      // Create CDW1 outside the test as it's used in the else clause.
      //

      CreateDWordField (Arg3, 0, CDW1)
      If (LEqual (Arg0, ToUUID("33DB4D5B-1FF7-401C-9657-7441C03DD766"))) {

        CreateDWordField (Arg3, 4, CDW2)
        CreateDWordField (Arg3, 8, CDW3)

        //
        // Save Capabilities DWord 2 & 3
        //

        Store (CDW2, SUPP)
        Store (CDW3, CTRL)

        //
        // Only allow native hot plug control if OS supports:
        //  ASPM
        //  Clock PM
        //  MSI/MSI-X
        //

        If (LNotEqual (And (SUPP, 0x16), 0x16)) {

          //
          // Mask bit 0 (and undefined bits)
          //

          And (CTRL, 0x1E, CTRL)
        }

        //
        // Never allow native Hot plug, PME.
        // Never allow SHPC (no SHPC controller in this system).
        // Only allow PCIe AER control if PCIe AER Firmware-First is disabled
        // Allows PCI Express Capability Structure control
        //

        If (AERF) {
          And (CTRL, 0x10, CTRL)
        } Else {
          And (CTRL, 0x18, CTRL)
        }

        //
        // Check for unknown revision.
        //

        If (LNotEqual (Arg1, One)) {
          Or (CDW1, 0x08, CDW1)
        }

        //
        // Check if capabilities bits were masked.
        //

        If (LNotEqual (CDW3, CTRL)) {
          Or (CDW1, 0x10, CDW1)
        }

        //
        // Update DWORD3 in the buffer.
        //

        Store (CTRL, CDW3)
        Return (Arg3)

      } Else {

        //
        // Unrecognized UUID
        //

        Or (CDW1, 4, CDW1)
        Return (Arg3)
      }
    } // End _OSC

    //
    // Declare a _DSM method for various functions called by the OS.
    // See the APCI spec, Section 9.14.1,
    // and the PCI FW spec, Section 4.6.
    // See also:
    // http://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/PCI-rsc.doc
    //

    Method (_DSM, 0x4, Serialized) {

      //
      // Match against the _DSM PCI GUID.
      //

      If (LEqual (Arg0, ToUUID("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {

        Switch (ToInteger(Arg2)) {
          //
          // Function 0: Return supported functions as a bitfield
          // with one bit for each supported function.
          // Bit 0 must always be set, as that represents
          // function 0 (which is what is being called here).
          // Support for different functions may depend on
          // the revision ID of the interface, passed as Arg1.
          //

          Case (0) {

              //
              // Functions 0-7 are supported.
              //

              Return (Buffer() {0x01})
          }
        }
      }

      //
      // If not one of the function identifiers we recognize, then return a buffer
      // with bit 0 set to 0 indicating no functions supported.
      //

      Return (Buffer() {0})
    }

    //
    // Root Port 0 Device within the Root Complex.
    //
    Device (RP0) {
      //
      // Device 0, Function 0.
      //

      Name (_ADR, 0x00000000)
    }

    //
    // Root Port 1
    //
    Device (P2P1) {
      //
      // Device 1, Function 0 (Bus 0).
      //

      Name (_ADR, 0x00010000)
      Name(_HPP, Package(){0x08,0x40, 0x01, 0x00})

      Device (S0F0) {
        //
        // On Bus 1 ([01])
        // Slot 0 (Device 0), Function 0
        //

        Name (_ADR, 0x00000000)

        Method (_STA, 0) {
          if (B120 == 0xF0000601) { // SW ejected before ?
            Store(0x02000601, B120) // clear action value
            Store(0x680000A4, DIN0) // Off RED LED
                                    // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                    // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
            Store(0x6800021A, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                    // action: Insert = 1 & Remove = 2
                                    // 0x6800021A to DBNS1_10
            Return(0xF)
          }
          elseif (B120 == 0x10000601) { // ejected complete ?
            Store(0x02000601, B120) // clear action value
            Return (0x0)
          }
          elseif ((B120 == 0x01000601) || (B120 == 0x0F000601)){ // inserted ?
            if (B28I == 0x00) {
              Store(0x02000601, B120) // clear action value
            }
            Return (0xF)
          }
          elseif ((B120 == 0x0E000601) || (B120 == 0x0F000601)) { // inprogress inserted ?
            if (B28I == 0x00) {
              Store(0x02000601, B120) // clear action value
            }
            Return (0xF)
          }
          else {
            Return (0xF)
          }
        }

        Method (_EJ0, 1) {
          if (B120 == 0x02000601) { // is sw ejection?
            Store(0xF0000601, B120) // set SW ejection event
            Store(0x680000B4, DIN0) // Blink RED LED
                                    // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                    // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
            Store(0x6800021A, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                    // action: Insert = 1 & Remove = 2
                                    // 0x6800021A to DBNS1_10
          }
        }

        Name(_SUN, 0x00000001)
      }
    }

    //
    // Root Port 3
    //
    Device (P2P3) {
      //
      // Device 3, Function 0 (Bus 0).
      //

      Name (_ADR, 0x00030000)
      Name(_HPP, Package(){0x08,0x40, 0x01, 0x00})

      Device (S0F0) {
        //
        // On Bus 2 [02])
        // Slot 0 (Device 0), Function 0
        //

        Name (_ADR, 0x00000000)

        Method (_STA, 0) {
          if (B122 == 0xF0020601) { // SW ejected before ?
            Store(0x02020601, B122) // clear action value
            Store(0x680000A4, DIN0) // Off RED LED
                                    // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                    // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
            Store(0x6800023A, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                    // action: Insert = 1 & Remove = 2
                                    // 0x6800023A to DBNS1_10
            Return(0xF)
          }
          elseif (B122 == 0x10020601) { // ejected completed ?
            Store(0x02020601, B122) // clear action value
            Return (0x0)
          }
          elseif ((B122 == 0x01020601) || (B122 == 0x0F020601)){ // inserted ?
            if (B29I == 0x00) {
              Store(0x02020601, B122) // clear action value
            }
            Return (0xF)
          }
          elseif ((B122 == 0x0E020601) || (B122 == 0x0F020601)) { // inprogress inserted ?
            if (B29I == 0x00) {
              Store(0x02020601, B122) // clear action value
            }
            Return (0xF)
          }
          else {
            Return (0xF)
          }
        }

        Method (_EJ0, 1) {
          if (B122 == 0x02020601) { // is sw ejection?
            Store(0xF0020601, B122) // set SW ejection event
            Store(0x680000B4, DIN0) // Blink RED LED
                                    // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                    // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
            Store(0x6800023A, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                    // action: Insert = 1 & Remove = 2
                                    // 0x6800023A to DBNS1_10
          }
        }

        Name(_SUN, 0x00000002)
      }
    }

    //
    // Root Port 5
    //
    Device (P2P5) {
      //
      // Device 5, Function 0 (Bus 0).
      //

      Name (_ADR, 0x00050000)
      Name(_HPP, Package(){0x08,0x40, 0x01, 0x00})

      Device (S0F0) {
        //
        // On Bus 3 [03])
        // Slot 0 (Device 0), Function 0
        //

        Name (_ADR, 0x00000000)

        Method (_STA, 0) {
          if (B124 == 0xF0040601) { // SW ejected before ?
            Store(0x02040601, B124) // clear action value
            Store(0x680000A4, DIN0) // Off RED LED
                                    // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                    // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
            Store(0x6800025A, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                    // action: Insert = 1 & Remove = 2
                                    // 0x6800025A to DBNS1_10
            Return(0xF)
          }
          elseif (B124 == 0x10040601) { // ejected complete ?
            Store(0x02040601, B124) // clear action value
            Return (0x0)
          }
          elseif ((B124 == 0x01040601) || (B124 == 0x0F040601)) { // inserted ?
            if (B30I == 0x00) {
              Store(0x02040601, B124) // clear action value
            }
            Return (0xF)
          }
          elseif ((B124 == 0x0E040601) || (B124 == 0x0F040601)) { // inprogress inserted ?
            if (B30I == 0x00) {
              Store(0x02040601, B124) // clear action value
            }
            Return (0xF)
          }
          else {
            Return (0xF)
          }
        }

        Method (_EJ0, 1) {
          if (B124 == 0x02040601) { // is sw ejection?
            Store(0xF0040601, B124) // set SW ejection event
            Store(0x680000B4, DIN0) // Blink RED LED
                                    // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                    // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
            Store(0x6800025A, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                    // action: Insert = 1 & Remove = 2
                                    // 0x6800025A to DBNS1_10
          }
        }

        Name(_SUN, 0x00000003)
      }
    }

    //
    // Root Port 7
    //
    Device (P2P7) {
      //
      // Device 7, Function 0 (Bus 0).
      //

      Name (_ADR, 0x00070000)
      Name(_HPP, Package(){0x08,0x40, 0x01, 0x00})

      Device (S0F0) {
        //
        // On Bus 4 ([04])
        // Slot 0 (Device 0), Function 0
        //

        Name (_ADR, 0x00000000)

        Method (_STA, 0) {
          if (B126 == 0xF0060601) { // SW ejected before ?
            Store(0x02060601, B126) // clear action value
            Store(0x680000A4, DIN0) // Off RED LED
                                    // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                    // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
            Store(0x6800027A, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                    // action: Insert = 1 & Remove = 2
                                    // 0x6800027A to DBNS1_10
            Return(0xF)
          }
          elseif (B126 == 0x10060601) { // ejected complete ?
            Store(0x02060601, B126) // clear action value
            Return (0x0)
          }
          elseif ((B126 == 0x01060601) || (B126 == 0x0F060601)) { // inserted ?
            if (B31I == 0x00) {
              Store(0x02060601, B126) // clear action value
            }
            Return (0xF)
          }
          elseif ((B126 == 0x0E060601) || (B126 == 0x0F060601)) { // inprogress inserted ?
            if (B31I == 0x00) {
              Store(0x02060601, B126) // clear action value
            }
            Return (0xF)
          }
          else {
            Return (0xF)
          }
        }

        Method (_EJ0, 1) {
          if (B126 == 0x02060601) { // is sw ejection?
            Store(0xF0060601, B126) // set SW ejection event
            Store(0x680000B4, DIN0) // Blink RED LED
                                    // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                    // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
            Store(0x6800027A, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                    // action: Insert = 1 & Remove = 2
                                    // 0x6800027A to DBNS1_10
          }
        }

        Name(_SUN, 0x00000004)
      }
    }

    Method (_PXM, 0, NotSerialized) {
      // Patch by code
      Return(0xFF)
    }
  } // PCIE RCB2

  // PCIF RCB3
  Device (PCIF) {
    //
    // Hardware ID must be PNP0A08, which maps to a PCIe root complex.
    // Section 6.1.5
    //

    Name (_HID, "PNP0A08")
    Name (_CCA, ONE)

    Method (_STA, 0, NotSerialized) {
      Return (0xF)                      // The default value is 0x0. Unfortunately, it breaks
                                        // run-time patching as the representation of 0 is special
                                        // encoding and cannot be patched to expand with extra bytes
                                        // easily. As such, we default to 0xF and patch this based
                                        // on whether the port was enabled or not by the BIOS.
    }

    //
    // Optionally, include a compatible ID of PNP0A03, which maps to a PCI
    // root complex for use with pre-PCIe operating systems.
    // Section 6.1.2
    //

    Name (_CID, "PNP0A03")

    //
    // Declare the segment number of this root complex. Most systems only
    // have one segment, which is numbered 0.
    // Section 6.5.6
    //

    Name (_SEG, 11)

    //
    // Declare the base bus number, which is the bus number of the root
    // bus in this root complex. This is usually 0, but need not be.
    // For root complexes supporting multiple root busses, this should
    // be the lowest numbered root bus.
    // Section 6.5.5
    //

    Name (_BBN, 0)

    //
    // The _UID value provides a way of uniquely identifying a device
    // in the case where more than one instance of a specific device
    // is implemented with the same _HID/_CID. For systems with a
    // single root complex, this is usually just 0. For systems with
    // multiple root complexes, this should be different for each
    // root complex.
    // Section 6.1.12
    //

    Name (_UID, "PCIF")
    Name (_STR, Unicode("PCIe 15 Device"))

    //
    // Declare the PCI Routing Table.
    // This defines SPI mappings of the four line-based interrupts
    // associated with the root complex and hierarchy below it.
    // Section 6.2.12
    //

    Name (_PRT, Package() {

      //
      // Routing for device 0, all functions.
      // Note: ARM doesn't support LNK nodes, so the third param
      // is 0 and the fourth param is the SPI number of the interrupt
      // line. In this example, the A/B/C/D interrupts are wired to
      // SPI lines 156/157/158/159 + 320 respectively. PCIF RCB3
      //
      Package() {0x0001FFFF, 0, 0, 476},
      Package() {0x0001FFFF, 1, 0, 477},
      Package() {0x0001FFFF, 2, 0, 478},
      Package() {0x0001FFFF, 3, 0, 479},
      Package() {0x0002FFFF, 0, 0, 476},
      Package() {0x0002FFFF, 1, 0, 477},
      Package() {0x0002FFFF, 2, 0, 478},
      Package() {0x0002FFFF, 3, 0, 479},
      Package() {0x0003FFFF, 0, 0, 476},
      Package() {0x0003FFFF, 1, 0, 477},
      Package() {0x0003FFFF, 2, 0, 478},
      Package() {0x0003FFFF, 3, 0, 479},
      Package() {0x0004FFFF, 0, 0, 476},
      Package() {0x0004FFFF, 1, 0, 477},
      Package() {0x0004FFFF, 2, 0, 478},
      Package() {0x0004FFFF, 3, 0, 479},
      Package() {0x0005FFFF, 0, 0, 476},
      Package() {0x0005FFFF, 1, 0, 477},
      Package() {0x0005FFFF, 2, 0, 478},
      Package() {0x0005FFFF, 3, 0, 479},
      Package() {0x0006FFFF, 0, 0, 476},
      Package() {0x0006FFFF, 1, 0, 477},
      Package() {0x0006FFFF, 2, 0, 478},
      Package() {0x0006FFFF, 3, 0, 479},
      Package() {0x0007FFFF, 0, 0, 476},
      Package() {0x0007FFFF, 1, 0, 477},
      Package() {0x0007FFFF, 2, 0, 478},
      Package() {0x0007FFFF, 3, 0, 479},
      Package() {0x0008FFFF, 0, 0, 476},
      Package() {0x0008FFFF, 1, 0, 477},
      Package() {0x0008FFFF, 2, 0, 478},
      Package() {0x0008FFFF, 3, 0, 479},
    })

    //
    // Declare the resources assigned to this root complex.
    // Section 6.2.2
    //
    Method (_CBA, 0, Serialized) {
      Return (0x6FFFF0000000)
    }

    //
    // Declare a ResourceTemplate buffer to return the resource
    // requirements from _CRS.
    // Section 19.5.109
    //

    Name (RBUF, ResourceTemplate () {

      //
      // Declare the range of bus numbers assigned to this root
      // complex. In this example, the minimum bus number will be
      // 0, the maximum bus number will be 0xFF, supporting
      // 256 busses total.
      // Section 19.5.141
      //

      WordBusNumber (
        ResourceProducer,
        MinFixed,   // IsMinFixed
        MaxFixed,   // IsMaxFixed
        PosDecode,  // Decode
        0,          // AddressGranularity
        0,          // AddressMinimum - Minimum Bus Number
        255,        // AddressMaximum - Maximum Bus Number
        0,          // AddressTranslation - Set to 0
        256)        // RangeLength - Number of Busses

      //
      // Declare the memory range to be used for BAR memory
      // windows. This declares a 4GB region starting at
      // 0x4000000000.
      // Section 19.5.80
      //
      // Memory32Fixed (ReadWrite, 0x1FE40000, 0x10000, )

      QWordMemory (
        ResourceProducer,     // ResourceUsage
        PosDecode,            // Decode
        MinFixed,             // IsMinFixed
        MaxFixed,             // IsMaxFixed
        NonCacheable,         // NonCacheable
        ReadWrite,            // ReadAndWrite
        0x0000000000000000,   // AddressGranularity - GRA
        0x0000000058000000,   // AddressMinimum - MIN
        0x000000005FFFFFFF,   // AddressMinimum - MAX
        0x0000000000000000,   // AddressTranslation - TRA
        0x0000000008000000    // RangeLength - LEN
      )

      QWordMemory (
        ResourceProducer,     // ResourceUsage
        PosDecode,            // Decode
        MinFixed,             // IsMinFixed
        MaxFixed,             // IsMaxFixed
        NonCacheable,         // NonCacheable
        ReadWrite,            // ReadAndWrite
        0x0000000000000000,   // AddressGranularity - GRA
        0x00006C0000000000,   // AddressMinimum - MIN
        0x00006FFFDFFFFFFF,   // AddressMinimum - MAX
        0x0000000000000000,   // AddressTranslation - TRA
        0x000003FFE0000000    // RangeLength - LEN
      )
    })

    Method (_CRS, 0, Serialized) {
      Return (RBUF)
    }

    //
    // Declare an _OSC (OS Control Handoff) method which takes 4 arguments.
    //
    // Argments:
    //   Arg0  A Buffer containing a UUID
    //   Arg1  An Integer containing a Revision ID of the buffer format
    //   Arg2  An Integer containing a count of entries in Arg3
    //   Arg3  A Buffer containing a list of DWORD capabilities
    // Return Value:
    //   A Buffer containing a list of capabilities
    // See the APCI spec, Section 6.2.10,
    // and the PCI FW spec, Section 4.5.
    //
    // The following is an example, and may need modification for
    // specific implementations.
    //

    Name (SUPP,0) // PCI _OSC Support Field value
    Name (CTRL,0) // PCI _OSC Control Field value

    Method (_OSC, 4) {

      //
      // Look for the PCI Host Bridge Interface UUID.
      // Section 6.2.10.3
      //

      //
      // Create DWord-adressable fields from the Capabilities Buffer
      // Create CDW1 outside the test as it's used in the else clause.
      //

      CreateDWordField (Arg3, 0, CDW1)
      If (LEqual (Arg0, ToUUID("33DB4D5B-1FF7-401C-9657-7441C03DD766"))) {

        CreateDWordField (Arg3, 4, CDW2)
        CreateDWordField (Arg3, 8, CDW3)

        //
        // Save Capabilities DWord 2 & 3
        //

        Store (CDW2, SUPP)
        Store (CDW3, CTRL)

        //
        // Only allow native hot plug control if OS supports:
        //  ASPM
        //  Clock PM
        //  MSI/MSI-X
        //

        If (LNotEqual (And (SUPP, 0x16), 0x16)) {

          //
          // Mask bit 0 (and undefined bits)
          //

          And (CTRL, 0x1E, CTRL)
        }

        //
        // Never allow native Hot plug, PME.
        // Never allow SHPC (no SHPC controller in this system).
        // Only allow PCIe AER control if PCIe AER Firmware-First is disabled
        // Allows PCI Express Capability Structure control
        //

        If (AERF) {
          And (CTRL, 0x10, CTRL)
        } Else {
          And (CTRL, 0x18, CTRL)
        }

        //
        // Check for unknown revision.
        //

        If (LNotEqual (Arg1, One)) {
          Or (CDW1, 0x08, CDW1)
        }

        //
        // Check if capabilities bits were masked.
        //

        If (LNotEqual (CDW3, CTRL)) {
          Or (CDW1, 0x10, CDW1)
        }

        //
        // Update DWORD3 in the buffer.
        //

        Store (CTRL, CDW3)
        Return (Arg3)

      } Else {

        //
        // Unrecognized UUID
        //

        Or (CDW1, 4, CDW1)
        Return (Arg3)
      }
    } // End _OSC

    //
    // Declare a _DSM method for various functions called by the OS.
    // See the APCI spec, Section 9.14.1,
    // and the PCI FW spec, Section 4.6.
    // See also:
    // http://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/PCI-rsc.doc
    //

    Method (_DSM, 0x4, Serialized) {

      //
      // Match against the _DSM PCI GUID.
      //

      If (LEqual (Arg0, ToUUID("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {

        Switch (ToInteger(Arg2)) {
          //
          // Function 0: Return supported functions as a bitfield
          // with one bit for each supported function.
          // Bit 0 must always be set, as that represents
          // function 0 (which is what is being called here).
          // Support for different functions may depend on
          // the revision ID of the interface, passed as Arg1.
          //

          Case (0) {

              //
              // Functions 0-7 are supported.
              //

              Return (Buffer() {0x01})
          }
        }
      }

      //
      // If not one of the function identifiers we recognize, then return a buffer
      // with bit 0 set to 0 indicating no functions supported.
      //

      Return (Buffer() {0})
    }

    //
    // Root Port 0 Device within the Root Complex.
    //
    Device (RP0) {
      //
      // Device 0, Function 0.
      //

      Name (_ADR, 0x00000000)
    }

    //
    // Root Port 1
    //
    Device (P2P1) {
      //
      // Device 1, Function 0 (Bus 0).
      //

      Name (_ADR, 0x00010000)
      Name(_HPP, Package(){0x08,0x40, 0x01, 0x00})

      Device (S0F0) {
        //
        // On Bus 1 ([01])
        // Slot 0 (Device 0), Function 0
        //

        Name (_ADR, 0x00000000)

        Method (_STA, 0) {
          if (B130 == 0xF0000701) { // SW ejected before ?
            Store(0x02000701, B130) // clear action value
            Store(0x680000A4, DIN0) // Off RED LED
                                    // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                    // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
            Store(0x6800021B, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                    // action: Insert = 1 & Remove = 2
                                    // 0x6800021B to DBNS1_10
            Return (0xF)
          }
          elseif (B130 == 0x10000701) { // ejected complete ?
            Store(0x02000701, B130) // clear action value
            Return (0x0)
          }
          elseif ((B130 == 0x01000701) || (B130 == 0x0F000701)) { // inserted ?
            if (B32I == 0x00) {
              Store(0x02000701, B130) // clear action value
            }
            Return (0xF)
          }
          elseif ((B130 == 0x0E000701) || (B130 == 0x0F000701)) { // inprogress inserted ?
            if (B32I == 0x00) {
              Store(0x02000701, B130) // clear action value
            }
            Return (0xF)
          }
          else {
            Return (0xF)
          }
        }

        Method (_EJ0, 1) {
          if (B130 == 0x02000701) { // is sw ejection?
            Store(0xF0000701, B130) // set SW ejection event
            Store(0x680000B4, DIN0) // Blink RED LED
                                    // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                    // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
            Store(0x6800021B, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                    // action: Insert = 1 & Remove = 2
                                    // 0x6800021B to DBNS1_10
          }
        }

        Name(_SUN, 0x00000001)
      }
    }

    //
    // Root Port 3
    //
    Device (P2P3) {
      //
      // Device 3, Function 0 (Bus 0).
      //

      Name (_ADR, 0x00030000)
      Name(_HPP, Package(){0x08,0x40, 0x01, 0x00})

      Device (S0F0) {
        //
        // On Bus 2 [02])
        // Slot 0 (Device 0), Function 0
        //

        Name (_ADR, 0x00000000)

        Method (_STA, 0) {
          if (B132 == 0xF0020701) { // SW ejected before ?
            Store(0x02020701, B132) // clear action value
            Store(0x680000A4, DIN0) // Off RED LED
                                    // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                    // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
            Store(0x6800023B, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                    // action: Insert = 1 & Remove = 2
                                    // 0x6800023B to DBNS1_10
            Return (0xF)
          }
          elseif (B132 == 0x10020701) { // ejected complete ?
            Store(0x02020701, B132) // clear action value
            Return (0x0)
          }
          elseif ((B132 == 0x01020701) || (B132 == 0x0F020701)) { // inserted ?
            if (B33I == 0x00) {
              Store(0x02020701, B132) // clear action value
            }
            Return (0xF)
          }
          elseif ((B132 == 0x0E020701) || (B132 == 0x0F020701)) { // inprogress inserted ?
            if (B33I == 0x00) {
              Store(0x02020701, B132) // clear action value
            }
            Return (0xF)
          }
          else {
            Return (0xF)
          }
        }

        Method (_EJ0, 1) {
          if (B132 == 0x02020701) { // is sw ejection?
            Store(0xF0020701, B132) // set SW ejection event
            Store(0x680000B4, DIN0) // Blink RED LED
                                    // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                    // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
            Store(0x6800023B, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                    // action: Insert = 1 & Remove = 2
                                    // 0x6800023B to DBNS1_10
          }
        }

        Name(_SUN, 0x00000002)
      }
    }

    //
    // Root Port 5
    //
    Device (P2P5) {
      //
      // Device 5, Function 0 (Bus 0).
      //

      Name (_ADR, 0x00050000)
      Name(_HPP, Package(){0x08,0x40, 0x01, 0x00})

      Device (S0F0) {
        //
        // On Bus 3 [03])
        // Slot 0 (Device 0), Function 0
        //

        Name (_ADR, 0x00000000)

        Method (_STA, 0) {
          if (B134 == 0xF0040701) { // SW ejected before ?
            Store(0x02040701, B134) // clear action value
            Store(0x680000A4, DIN0) // Off RED LED
                                    // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                    // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
            Store(0x6800025B, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                    // action: Insert = 1 & Remove = 2
                                    // 0x6800025B to DBNS1_10
            Return (0xF)
          }
          elseif (B134 == 0x10040701) { // ejected completed ?
            Store(0x02040701, B134) // clear action value
            Return (0x0)
          }
          elseif ((B134 == 0x01040701) || (B134 == 0x0F040701)) { // inserted ?
            if (B34I == 0x00) {
              Store(0x02040701, B134) // clear action value
            }
            Return (0xF)
          }
          elseif ((B134 == 0x0E040701) || (B134 == 0x0F040701)) { // inprogress inserted ?
            if (B34I == 0x00) {
              Store(0x02040701, B134) // clear action value
            }
            Return (0xF)
          }
          else {
            Return (0xF)
          }
        }

        Method (_EJ0, 1) {
          if (B134 == 0x02040701) { // is sw ejection?
            Store(0xF0040701, B134) // set SW ejection event
            Store(0x680000B4, DIN0) // Blink RED LED
                                    // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                    // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
            Store(0x6800025B, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                    // action: Insert = 1 & Remove = 2
                                    // 0x6800025B to DBNS1_10
          }
        }

        Name(_SUN, 0x00000003)
      }
    }

    //
    // Root Port 7
    //
    Device (P2P7) {
      //
      // Device 7, Function 0 (Bus 0).
      //

      Name (_ADR, 0x00070000)
      Name(_HPP, Package(){0x08,0x40, 0x01, 0x00})

      Device (S0F0) {
        //
        // On Bus 4 ([04])
        // Slot 0 (Device 0), Function 0
        //

        Name (_ADR, 0x00000000)

        Method (_STA, 0) {
          if (B136 == 0xF0060701) { // SW ejected before ?
            Store(0x02060701, B136) // clear action value
            Store(0x680000A4, DIN0) // Off RED LED
                                    // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                    // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
            Store(0x6800027B, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                    // action: Insert = 1 & Remove = 2
                                    // 0x6800027B to DBNS1_10
            Return (0xF)
          }
          elseif (B136 == 0x10060701) { // ejected completed ?
            Store(0x02060701, B136) // clear action value
            Return (0x0)
          }
          elseif ((B136 == 0x01060701) || (B136 == 0x0F060701)) { // inserted ?
            if (B35I == 0x00) {
              Store(0x02060701, B136) // clear action value
            }
            Return (0xF)
          }
          elseif ((B136 == 0x0E060701) || (B136 == 0x0F060701)) { // inprogress inserted ?
            if (B35I == 0x00) {
              Store(0x02060701, B136) // clear action value
            }
            Return (0xF)
          }
          else {
            Return (0xF)
          }
        }

        Method (_EJ0, 1) {
          if (B136 == 0x02060701) { // is sw ejection?
            Store(0xF0060701, B136) // set SW ejection event
            Store(0x680000B4, DIN0) // Blink RED LED
                                    // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                    // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
            Store(0x6800027B, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                    // action: Insert = 1 & Remove = 2
                                    // 0x6800027B to DBNS1_10
          }
        }

        Name(_SUN, 0x00000004)
      }
    }

    Method (_PXM, 0, NotSerialized) {
      // Patch by code
      Return(0xFF)
    }
  } // PCIF RCB3
